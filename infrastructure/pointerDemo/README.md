# 指针
区别于C/C++中的指针，Go语言中的指针**不能进行偏移和运算**，是安全指针。

任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的**地址**，我们就需要指针变量。

Go语言中的指针不能进行偏移和运算，因此Go语言中的指针操作非常简单，我们只需要记住两个符号：**`&`（取地址）和`*`（根据地址取值）**。

指针是一个指向某个确切的内存地址的值。这个内存地址可以是任何数据或代码的**起始地址**

## 指针地址和指针类型

取变量指针的语法如下：

```go
ptr := &v    // v的类型为T
```

其中：

- v:代表被取地址的变量，类型为`T`
- ptr:用于接收地址的变量，ptr的类型就为`*T`，称做T的**指针类型**。*代表指针。

```go
func main() {
	a := 10
	b := &a
	fmt.Printf("a:%d ptr:%p\n", a, &a) // a:10 ptr:0xc00001a078
	fmt.Printf("b:%p type:%T\n", b, b) // b:0xc00001a078 type:*int
	fmt.Println(&b)                    // 0xc00000e018
}
```

通过 var 声明的指针变量是不能直接赋值和取值的，因为这时候它仅仅是个变量，还没有对应的内存地址，它的值是 nil。

```go
var intP *int
intP = &name //指针类型不同，无法赋值
```

## 指针取值

在对**普通变量**使用&操作符取地址后会获得这个变量的指针，然后可以对指针使用*操作，也就是指针取值



```go
func main() {
	//指针取值
	a := 10
	b := &a // 取变量a的地址，将指针保存到b中
	fmt.Printf("type of b:%T\n", b)
	c := *b // 指针取值（根据指针去内存取值）
	fmt.Printf("type of c:%T\n", c)
	fmt.Printf("value of c:%v\n", c)
}

//output
type of b:*int
type of c:int
value of c:10
```

**总结：** 取地址操作符`&`和取值操作符`*`是一对互补操作符，`&`取出地址，`*`根据地址取出地址指向的值。

变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：

- 对变量进行取地址（&）操作，可以获得这个变量的指针变量。
- 指针变量的值是指针地址。
- 对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。



**指针传值示例：**

```go
func modify1(x int) {
	x = 100               
}

func modify2(x *int) {    //传的是指针，即地址
	*x = 100
}

func main() {
	a := 10
	modify1(a)
	fmt.Println(a) // 10 
	modify2(&a)
	fmt.Println(a) // 100
}
```



## 指针接收者

对于是否使用指针类型作为接收者，有以下几点参考：

1. 如果接收者类型是 map、slice、channel 这类引用类型，不使用指针；
2. 如果需要修改接收者，那么需要使用指针；
3. 如果接收者是比较大的类型，可以考虑使用指针，因为内存拷贝廉价，所以效率高。
4. 像 int、bool 这样的小数据类型没必要使用指针；
5. 如果需要并发安全，则尽可能地不要使用指针，使用指针一定要保证并发安全；
6. 指针最好不要嵌套，也就是不要使用一个指向指针的指针，虽然 Go 语言允许这么做，但是这会使你的代码变得异常复杂。

## new和make

```go
func main() {
	var a *int
	*a = 100
	fmt.Println(*a)

	var b map[string]int
	b["沙河娜扎"] = 100
	fmt.Println(b)
}
```

执行上面的代码会引发panic，为什么呢？ 在Go语言中对于**引用类型的变量**，我们在使用的时候**不仅要声明它**，还要为它**分配内存空间**，否则我们的值就没办法存储。而对于**值类型**的声明**不需要分配内存空间**，是因为它们在**声明的时候已经默认分配好了内存空间**。要分配内存，就引出来今天的new和make。 Go语言中**new和make**是内建的两个函数，主要用来**分配内存**。



### new

new是一个内置的函数，它的函数签名如下：

```go
func new(Type) *Type
```

其中，

- Type表示类型，new函数**只接受一个参数**，这个参数是**一个类型**
- *Type表示类型指针，new函数返回一个指向该类型**内存地址的指针**。

new函数不太常用，使用new函数得到的是一个类型的指针，并且该指针对应的值为该**类型的零值**。



```go
func main() {
	a := new(int)
	b := new(bool)
	fmt.Printf("%T\n", a) // *int
	fmt.Printf("%T\n", b) // *bool
	fmt.Println(*a)       // 0
	fmt.Println(*b)       // false
  fmt.Println(a)				//0xc0000b2008
	fmt.Println(b)				//0xc0000b2010
}	
```

开始的示例代码中`var a *int`只是声明了一个指针变量a但是没有初始化，指针作为引用类型需要初始化后才会拥有内存空间，才可以给它赋值。应该按照如下方式使用内置的new函数对a进行初始化之后就可以正常对其赋值了：

```go
func main() {
	var a *int
	a = new(int)
	*a = 10
	fmt.Println(*a)
}
```

### make

make也是用于内存分配的，区别于new，它只用于slice、map以及channel的内存创建，而且它**返回的类型就是这三个类型本身**的一个**已初始化** （而非**置零**）的值，而不是他们的指针类型，因为这**三种类型就是引用类型**，所以就没有必要返回他们的指针了。这三种类型本质上为引用数据类型，它们在使用前必须初始化。make函数的函数签名如下：

```go
func make(t Type, size ...IntegerType) Type
```

make函数是无可替代的，我们在使用slice、map以及channel的时候，都需要使用make进行初始化，然后才可以对它们进行操作。

开始的示例中`var b map[string]int`只是声明变量b是一个map类型的变量，需要像下面的示例代码一样使用make函数进行初始化操作之后，才能对其进行键值对赋值：

```go
func main() {
	var b map[string]int
	b = make(map[string]int, 10)
	b["沙河娜扎"] = 100
	fmt.Println(b)
}
```

### new与make的区别

1. 二者都是用来做内存分配的。
2. make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身；
3. 而new用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。

## 思考题：

### 你能列举出 Go 语言中的哪些值是不可寻址的吗？

- 常量的值
- 基本类型值的字面量
- 算术操作的结果值
- 对各种字面量的索引表达式和切片表达式的结果值。不过有一个**例外**，对切片字面量的索引结果值却是可寻址的
- 对字符串变量的索引表达式和切片表达式的结果值
- 对字典变量的索引表达式的结果值
- 函数字面量和方法字面量，以及对它们的调用表达式的结果值
- 结构体字面量的字段值，也就是对结构体字面量的选择表达式的结果值
- 类型转换表达式的结果值
- 类型断言表达式的结果值
- 接收表达式的结果值



解析：

常量的值总是会被存储到一个确切的内存区域中，并且这种值肯定是**不可变**的。基本类型值的字面量也是一样，其实它们本就可以被视为常量，只不过没有任何标识符可以代表它们罢了。

第一个关键词：**不可变的**。由于 Go 语言中的字符串值也是不可变的，所以对于一个字符串类型的变量来说，基于它的索引或切片的结果值也都是不可寻址的，因为即使拿到了这种值的内存地址也改变不了什么。

算术操作的结果值属于一种**临时结果**。在我们把这种结果值赋给任何变量或常量之前，即使能拿到它的内存地址也是没有任何意义的。

第二个关键词：**临时结果**。这个关键词能被用来解释很多现象。我们可以把各种对值字面量施加的表达式的求值结果都看做是临时结果。

一个需要特别注意的例外是，**对切片字面量的索引结果值是可寻址的**。因为不论怎样，每个切片值都会持有一个底层数组，而这个底层数组中的每个元素值都是有一个确切的内存地址的。

你可能已经注意到了，我一直在说针对数组值、切片值或字典值的**字面量**的表达式会产生临时结果。如果针对的是数组类型或切片类型的**变量**，那么索引或切片的结果值就都不属于临时结果了，是可寻址的。这主要因为变量的值本身就不是“临时的”。对比而言，值字面量在还没有与任何变量（或者说任何标识符）绑定之前是没有落脚点的，我们无法以任何方式引用到它们。这样的值就是“临时的”。

再说一个例外。我们通过对**字典类型的变量**施加索引表达式，得到的结果值不属于临时结果，可是，这样的值却是**不可寻址**的。原因是，字典中的每个键 - 元素对的存储位置都可能会变化，而且这种变化外界是无法感知的。我们都知道，字典中总会有若干个哈希桶用于均匀地储存键 - 元素对。当满足一定条件时，字典可能会改变哈希桶的数量，并适时地把其中的键 - 元素对搬运到对应的新的哈希桶中。在这种情况下，获取字典中任何元素值的指针都是无意义的，也是**不安全**的。我们不知道什么时候那个元素值会被搬运到何处，也不知道原先的那个内存地址上还会被存放什么别的东西。所以，这样的值就应该是不可寻址的。

第三个关键词：**不安全的**。“不安全的”操作很可能会破坏程序的一致性，引发不可预知的错误，从而严重影响程序的功能和稳定性。

再来看函数。函数在 Go 语言中是一等公民，所以我们可以把代表函数或方法的字面量或标识符赋给某个变量、传给某个函数或者从某个函数传出。但是，这样的函数和方法都是不可寻址的。一个原因是函数就是代码，是不可变的。另一个原因是，拿到指向一段代码的指针是不安全的。此外，对函数或方法的调用结果值也是不可寻址的，这是因为它们都属于临时结果。

如果我们把**临时结果赋给一个变量**，那么它就是**可寻址**的了。如此一来，取得的指针指向的就是这个变量持有的那个值了。



### 不可寻址的值在使用上有什么限制

```go
type Dog struct {
  name string
}
func (dog *Dog) SetName(name string) {
  dog.name = name
}
```



```go
func New(name string) Dog {
  return Dog{name}
}
```



我们再为它编写一个函数New。这个函数会接受一个名为name的string类型的参数，并会用这个参数初始化一个Dog类型的值，最后返回该值。我现在要问的是：如果我调用该函数，并直接以**链式的手法**调用其结果值的指针方法SetName，那么可以达到预期的效果吗？

```go
New("little pig").SetName("monster")
```

调用New函数所得到的结果值属于临时结果，是不可寻址的。可是，那又怎样呢？别忘了，我在讲结构体类型及其方法的时候还说过，我们可以在一个基本类型的值上调用它的指针方法，这是因为 Go 语言会自动地帮我们转译。更具体地说，对于一个Dog类型的变量dog来说，调用表达式dog.SetName("monster")会被自动地转译为(&dog).SetName("monster")，即：先取dog的指针值，再在该指针值上调用SetName方法。发现问题了吗？**由于New函数的调用结果值是不可寻址的，所以无法对它进行取址操作。**因此，上边这行链式调用会让编译器报告两个错误，一个是果，即：不能在New("little pig")的结果值上调用指针方法。一个是因，即：不能取得New("little pig")的地址。

除此之外，我们都知道，Go 语言中的++和--并不属于操作符，而分别是**自增语句和自减语句**的重要组成部分。虽然 Go 语言规范中的语法定义是，只要在++或--的左边添加一个表达式，就可以组成一个自增语句或自减语句，但是，它还明确了一个很重要的限制，**那就是这个表达式的结果值必须是可寻址的。这就使得针对值字面量的表达式几乎都无法被用在这里。**

不过这有一个例外，虽然对字典字面量和字典变量索引表达式的结果值都是不可寻址的，但是这样的表达式却可以被用在自增语句和自减语句中。与之类似的规则还有两个。一个是，在赋值语句中，赋值操作符左边的表达式的结果值必须可寻址的，但是对字典的索引结果值也是可以的。另一个是，在带有range子句的for语句中，在range关键字左边的表达式的结果值也都必须是可寻址的，不过对字典的索引结果值同样可以被用在这里。以上这三条规则我们合并起来记忆就可以了。与这些定死的规则相比，我刚刚讲到的那个与指针方法有关的问题，你需要好好理解一下，它涉及了两个知识点的联合运用。起码在我面试的时候，它是一个可选择的考点。

### 引用类型的值的指针值是有意义的吗？如果没有意义，为什么？如果有意义，意义在哪里？

从存储和传递的角度看，没有意义。因为引用类型的值已经相当于指向某个底层数据结构的指针了。当然，引用类型的值不只是指针那么简单。


# 变量声明
变量代表可变的数据类型，也就是说，它在程序执行的过程中可能会被**一次甚至多次修改。**
## 变量声明的两种方式
```go
var 变量名 类型 = 表达式

var (
    j = 0
    k = 1
)
var s string //只指定了类型
```
使用 var ，虽然只指定了类型，但是 Go 会对其进行**隐式初始化**，比如 string 类型就初始化为空字符串，int 类型就初始化为0，float 就初始化为 0.0，bool类型就初始化为false，指针类型就初始化为 nil。

有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来**推导变量**的类型完成初始化。

若你的右值带有小数点，在**不指定类型**的情况下，编译器会将你的这个变量声明为 **float64**，但是很多情况下，我们并不需要这么高的精度（占用的内存空间更大）。

普通变量，存放的是数据本身，而**指针变量存放的是数据的地址**。

**匿名变量**，也称作占位符，或者空白标识符，用下划线表示。

- 不分配内存，不占用内存空间
- 不需要你为命名无用的变量名而纠结
- 多次声明不会有任何问题

使用表达式 new(Type) 将创建一个Type类型的匿名变量，初始化为Type类型的零值，然后**返回变量地址**，返回的指针类型为`*Type`。

```GO
pr := new(int) //返回类型是*int 返回的是地址，值为该类型的零值

//即 *pr = 0
```


我们只能在**函数体内部**使用**短变量声明**。在编写if、for或switch语句的时候，我们经常把它安插在初始化子句中，并用来声明一些临时的变量。而相比之下，第一种方式更加通用，它可以被用在任何地方。

```go
f, err := os.Open(name)
d, err := f.Stat()
```
注意，尽管两个语句中都出现了 err，但这种重复仍然是合法的：err 在第一条语句中被声明，但在第二条语句中只是被再次赋值罢了。也就是说，调用 f.Stat 使用的是前面已经声明的 err，它只是被**重新赋值**了而已。

在满足下列条件时，已被声明的变量 `v` 可出现在`:=` 声明中：

- 本次声明与已声明的 `v` 处于**同一作用域**中（若 `v` 已在外层作用域中声明过，则此次声明会创建一个新的变量 §），
- 在初始化中与其**类型相应**的值才能赋予 `v`，且在此次声明中至少另有一个变量是新声明的。

§ 值得一提的是，即便 Go 中的函数形参和返回值在词法上处于大括号之外， 但它们的作用域和该函数体仍然相同。

## Go 语言的类型推断可以带来哪些好处？
```go
func getTheFlag() *string {
	return flag.String("name","everyone","the greeting object")
}
func main() {
 var name = getTheFlag()
 	flag.Parse()
 	fmt.Printf("Hello, %v!\n", *name)
}
```
我们不显式地指定变量name的类型，使得它可以被赋予任何类型的值。也就是说，变量name的类型可以在其初始化时，由其他程序**动态**地确定。

如果只用一两句话回答这个问题的话，我想可以是这样的：**Go 语言的类型推断可以明显提升程序的灵活性，使得代码重构变得更加容易，同时又不会给代码的维护带来额外负担（实际上，它恰恰可以避免散弹式的代码修改），更不会损失程序的运行效率。**

**基于类型推断，Go 语言的类型推断只应用在了对变量或常量的初始化方面。**

## 如果与当前的变量重名的是外层代码块中的变量，那么这意味着什么？
```go
package main

import "fmt"

var block = "package"

func main() {
  block := "function"
  {
    block := "inner"
    fmt.Printf("The block is %s.\n", block)
  }
  fmt.Printf("The block is %s.\n", block)
}
```
这个命令源码文件中有四个代码块，它们是：全域代码块、main包代表的代码块、main函数代表的代码块，以及在main函数中的一个用花括号包起来的代码块。

打印结果
```shell script
The block is inner.
The block is function.
```
初看这道题，你可能会认为它无法通过编译，因为三处代码都声明了相同名称的变量。**的确，声明重名的变量是无法通过编译的，用短变量声明对已有变量进行重声明除外，但这只是对于同一个代码块而言的。**

- 首先，代码引用变量的时候总会**最优先查找当前代码块中**的那个变量。注意，这里的“当前代码块”仅仅是引用变量的代码所在的那个代码块，**并不包含任何子代码块**。
- 其次，如果当前代码块中没有声明以此为名的变量，那么程序会沿着代码块的嵌套关系，从**直接包含当前代码块**的那个代码块开始，一层一层地查找。
- 一般情况下，程序会一直查到当前代码包代表的代码块。如果仍然找不到，那么 Go 语言的编译器就会报错了。

在当前源码文件中**导入了其他代码包**，那么引用其中的程序实体时，是需要以**限定符为前缀**的。所以程序在找代表变量**未加限定符**的名字（即标识符）的时候，是**不会去被导入的代码包**中查找的。

> 但有个特殊情况，如果我们把代码包导入语句写成import . "XXX"的形式（**注意中间的那个“.”**），那么就会让这个“XXX”包中**公开的程序实体**，被当前源码文件中的代码，视为当前代码包中的程序实体。 比如，如果有代码包导入语句import . fmt，那么我们在当前源码文件中引用fmt.Printf函数的时候直接用Printf就可以了。在这个**特殊情况**下，程序在查找当前源码文件后会先去查用这种方式导入的那些代码包。
>

## 不同代码块中的重名变量与变量重声明中的变量区别到底在哪儿？
为了方便描述，我就把不同代码块中的重名变量叫做“可重名变量”吧**

- 变量重声明中的变量一定是在某一个代码块内的。注意，这里的“某一个代码块内”并不包含它的任何子代码块，否则就变成了“多个代码块之间”。而可重名变量指的正是在多个代码块之间由相同的标识符代表的变量。
- 变量重声明是对同一个变量的多次声明，这里的变量只有一个。而可重名变量中涉及的变量肯定是有多个的。
- 不论对变量重声明多少次，其类型必须始终一致，具体遵从它第一次被声明时给定的类型。而可重名变量之间不存在类似的限制，它们的类型可以是任意的。
- 如果可重名变量所在的代码块之间，存在直接或间接的嵌套关系，那么它们之间一定会存在“屏蔽”的现象。但是这种现象绝对不会在变量重声明的场景下出现。

## 如果通过import . XXX这种方式导入的代码包中的变量与当前代码包中的变量重名了，那么 Go 语言是会把它们当做“可重名变量”看待还是会报错呢？
这两个变量会成为“可重名变量”。虽然这两个变量在这种情况下的作用域都是当前代码包的当前文件，但是它们**所处的代码块是不同的**。当前文件中的变量处在该文件所代表的代码块中，而**被导入的代码包中的变量却处在声明它的那个文件所代表的代码块中**。当然，我们也可以说被导入的代码包所代表的代码块包含了这个变量。在当前文件中，**本地的变量会“屏蔽”掉被导入的变量**。

# 常量
**常量只能是数字、字符（符文）、字符串或布尔值**。由于编译时的限制， 定义它们的表达式必须也是可被编译器求值的常量表达式。例如 1<<3 就是一个常量表达式，而 math.Sin(math.Pi/4) 则不是，因为对 math.Sin 的函数调用在运行时才会发生。

`iota`在const关键字出现时将被重置为0。const中每新增一行**常量声明**将使`iota`计数一次(iota可理解为const语句块中的**行索引**)。
```go
type ByteSize float64

const (     //iota被重设为0
    _           = iota // 通过赋予空白标识符来忽略第一个值    iota=0
    KB ByteSize = 1 << (10 * iota)    //iota=1
    MB                                //iota=2
    GB
    TB   //如果连个const赋值语句的表达式是一样的，可以省略后一个表达式
    PB
    EB
    ZB
    YB
)

const (
   c0 = iota     // 0
   c1
   c2 = 4
   c3 = iota     //3
)
```
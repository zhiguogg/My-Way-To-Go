# 数组
以下为数组在 Go 和 C 中的主要区别。在 Go 中，

- 数组是值。将一个数组赋予另一个数组会复制其所有元素。
- 特别地，若将某个数组传入某个函数，它将接收到该数组的一份**副本**而非指针。
- 数组的大小是其类型的一部分。类型 `[10]int` 和 `[20]int` 是不同的。

在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是**数组大小不可变化**

```go
// 定义一个长度为3元素类型为int的数组a
var a [3]int
```

数组存放的是固定长度、相同类型的数据，而且这些存放的元素是连续的。所存放的数据类型没有限制，可以是整型、字符串甚至自定义。

## 数组声明
初始化数组时可以使用**初始化列表**来设置数组元素的值。
```go
func declareArray()  {
	var testArray1 [3]int  //数组会初始化为int类型的零值
	var testArray2 [3]int= [3]int{7,4}  // 可以省略 前面的[3]int
	var cityArray = [...]string{"北京", "上海", "深圳"}   // 编译器根据初始值的个数自行推断数组的长度
	fmt.Println(testArray1,testArray2,cityArray)
}
```
按照上面的方法每次都要确保提供的初始值和数组长度一致，一般情况下我们可以让**编译器根据初始值的个数自行推断数组的长度**
我们还可以使用**指定索引值的方式来初始化数组**，例如:
```go
a := [...]int{0:2,2:4,5:1}  //注意冒号
	fmt.Println(a) // [2 0 4 0 0 1]
```

## 数组遍历
遍历数组a有以下两种方法：
```go
func traverse()  {
	var a = [...]string{"北京", "上海", "深圳"}
	// 方法1：for循环遍历
	for i := 0; i < len(a); i++ {
		fmt.Println(a[i])
	}

	// 方法2：for range遍历
	for index, value := range a {
		fmt.Println(index, value)
	}
}
```

# 多维数组
## 二维数组的定义
```go
func twoDimensionalArray() {
	a := [3][2]string{
		{"北京", "上海"},
		{"广州", "深圳"},
		{"成都", "重庆"},
	}
	fmt.Println(a) //[[北京 上海] [广州 深圳] [成都 重庆]]
	fmt.Println(a[2][1]) //支持索引取值:重庆
}
```
二维数组本质是数组的数组，第一个[]是外层数组的元素个数，每一个元素都是一个数组，第二个[]就是里面的数组元素的个数。

### 二维数组的遍历
```go
func traverseArray2() {
	a := [2][3]string{
		{"安徽", "合肥", "大蜀山"},
		{"江苏", "南京", "雨花台"},
	}
	for _, value := range a {
		for _, value := range value { //注意这两个value的作用域，最好起不一样的名字
			fmt.Println(value)
		}
	}
}
//打印结果
安徽
合肥
大蜀山
江苏
南京
雨花台

```

多维数组**只有第一层**可以使用`...`来让编译器推导数组长度
```go
//支持的写法
a := [...][2]string{
	{"北京", "上海"},
	{"广州", "深圳"},
	{"成都", "重庆"},
}
//不支持多维数组的内层使用...
b := [3][...]string{
	{"北京", "上海"},
	{"广州", "深圳"},
	{"成都", "重庆"},
}
```

### 数组是值类型
数组是值类型，赋值和传参会**复制整个数组**。因此改变副本的值，**不会改变本身的值**。
```go
func modifyArray(x [3]int) {
	x[0] = 100
}

func modifyArray2(x [3][2]int) {
	x[2][0] = 100
}
func changeArray() {
	a := [3]int{10, 20, 30}
	modifyArray(a) //在modify中修改的是a的副本x
	fmt.Println(a) //[10 20 30]
	b := [3][2]int{
		{1, 1},
		{1, 1},
		{1, 1},
	}
	modifyArray2(b) //在modify中修改的是b的副本x
	fmt.Println(b)  //[[1 1] [1 1] [1 1]]
}
```
**注意：**

1. 数组支持 “==“、”!=” 操作符，因为**内存总是被初始化过**的。
2. `[n]*T`表示指针数组，`*[n]T`表示数组指针 。

数组为值的属性很有用，但代价高昂；若你想要 C 那样的行为和效率，你可以传递一个指向该数组的指针。

```GO
func Sum(a *[3]float64) (sum float64) {
    for _, v := range *a {
        sum += v
    }
    return
}

array := [...]float64{7.0, 8.5, 9.1}
x := Sum(&array)  // Note the explicit address-of operator
```

但这并不是 Go 的习惯用法，**切片**才是。